# 완전 탐색

완전 탐색

* for문

  

# 문자열

* substring()

  ```java
  String temp = str.substring(시작idx, 끝idx+1);
  ```

* split()

  ```java
  String[] str = str.split("문자열");	// 문자열
  String[] str = str.split("//특수문자열");	// 특수문자열
  String[] str = str.split("문자열|문자열")	// 여러 문자열
  ```

* replaceAll()

  ```java
  // ~제외 제거 [^문자]
  str = str.replaceAll("[^a-z]",""); // a-z를 제외 제거
  str = str.replaceAll("[^a-z0-9-_.]",""); // 알파벳, 숫자, -_. 제외 제거
  
  // 처음, 마지막거 제거	^[문자]  ,  [문자]$
  str = str.replaceAll("^[.]",""); // 처음. 제거
  str = str.replaceAll("[.]$",""); // 마지막. 제거
  str = str.replaceAll("^[.]|[.]$", ""); // 처음, 마지막. 모두 제거  
  
  // 여러 문자 제거  |  띄어쓰기 ㄴㄴ
  str = str.replaceAll("[문자]|[문자]", ""); 
  
  // 연속 반복 치환
  str = str.replaceAll("[.]{2,}","."); // 연속2개 이상 -> 1개
  ```

* charAt()

  ```java
  char c = s.charAt(idx);
  ```

* trim() : 맨앞, 뒤 공백 제거

  ```java
  String str = str.trim();
  ```

* 아스키 코드

  ```java
  int index = 'a';			 // 아스키 코드
  char temp = (char)index; 	 // 문자
  int num = Character.getNumericValue(c);	// '숫자문자' -> 숫자
  ```

* 대소문자

  ```java
  // 문자열
  String str = "AsD";
  str.toLowerCase();	// 소문자
  str.toUpperCase();	// 대문자
  
  // 문자
  char = 'a';
  Character.toLowerCase(c);	// 소문자
  Character.toUpperCase(c);	// 대문자
  ```

* 확인

  ```java
  Character.isDigit(c);			// 숫자
  Character.isAlphabetic(c);		// 알파벳
  Character.isUpperCase(c);		// 대문자
  Character.isLowerCase(c);		// 소문자
  ```


* 같은지 확인 : equals()

  ```java
  "a".equals("b") // false
  "a".equals("a") // false
  ```

* 비교 compareTo() 

  대소문자 같아야 비교 가능

  ```java
  "a".compareTo("b")  // -1
  "a".comapreTo("a")  // 0
  "b".comapreTo("a")  // 1
  ```

* 길이 : length()

  ```java
  "a".length() // 1
  ```

* 인덱스 : indexOf()

  ```java
  "asdfa".indexOf("a") // 0
  ```

  

# 자료구조

## arr

* 사용하는 경우

  크기 불변

* 초기화

  int[] arr = new int[N];

* 함수

  Arrays.sort(), Arrays.fill()

* 얕은 복사

  Arrays.copy()

* 깊은 복사 

  `graph[i][j] = arr[i][j]`



## List

* 사용하는 경우

  크기 모를 때

* 초기화

  List<자료형> list = new ArrayList<>();

* 함수

  list.add(), list.remove(), list.indexOf()



## Heapq

* 사용하는 경우

  정렬, 다익스트라

* 초기화

  PriorityQueue<> pq = new PriorityQueue<>()

* 함수

  pq.add(), pq.poll()



## Stack

* 사용하는 경우

  LIFO, 오큰수

* 초기화

  Stack<> st = new Stack<>()

* 함수

  st.add(), st.pop()



## Queue

* 사용하는 경우

  FIFO, 무게제한 다리건너기

* 초기화

  Queue<> q = new LinkedList<>()

* 함수

  q.add(), q.poll()



## Map

* 사용하는 경우

  모든 데이터 타입으로 접근 가능한 key-value 자료구조(HashMap, TreeMap)

  * 갯수

  * String idx화
  * String - list

* 함수

  get(), put(), getOrDefault()

* 사용하는 경우

  String 기반으로 기록하고 관리할 때

* key 정렬 : TreeMap



## Set

* 사용하는 경우

  중복 ㄴ

* key 정렬 : TreeSet



# 구현

1. 회전

   





# BFS / DFS

그래프 탐색 알고리즘

* 개념
  * bfs : 여러 드라마 하나씩 보기 
  * dfs : 한 드라마 끝까지 다보기

* 대표 유형
  * 경로 탐색(최단거리, 시간)
  * 네트워크 유형(연결) - 덩어리 크기, 덩어리 갯수
  * 조합 만들기

* 구현 방법
  * dfs:  재귀
  * bfs: Queue, LinkedList(순서보장)

* 사용하는 경우
  * dfs : 시간 복잡도가 높음, 디버깅이 쉬움 -> 난이도가 낮은 경우 dfs
  * bfs : 시간 복잡도가 낮음(O(V+E)) -> 난이도가 높거나, dfs 너무 오래걸리는 경우 사용



```java
Queue<int[]> q = new LinkedList<>();
boolean[][] visited = new boolean[n][m];
int ans = 0;

q.add(new int[] {x,y});
visited[x][y] = true;

while(!q.isEmpty()) {
	int len = q.size();
	
	for(int t=0;t<len;t++) {
		int[] now = q.poll();
	
        for(int i=0;i<4;i++) {
            int nx = now[0] + dx[i];
            int ny = now[1] + dy[i];

            if(nx < 0 || nx >= n || ny < 0 || ny >= m) continue;	// 범위
            if(visited[nx][ny]) continue;	// 중복
            if()							// 조건

            q.add(new int[] {nx,ny});
            visited[nx][ny] = true;
		}
	}
	ans++;
}
```



# 재귀

## 메모라이제이션

* 사용하는 경우

  시간 초과나는 

* 사용법

  dp 써서 반복을 막자



## 분할정복

* 사용하는 경우

  범위만 뀌는 경우



## 백트래킹(순열, 조합)

1. 순열

   ```java
   dfs(int depth, boolean[] visited);
   ```

2. 조합

   ```java
   dfs(int depth, int idx);
   ```



```
public void dfs(int[][] a) {
	ans = ~;
	a = ans // 이거하면 a 안바뀜
}

public void dfs(int[][] a) {
	ans = ~;
	return ans
}
a = dfs(a); // 이렇게 해야 바뀜
```





# 그리디

## 정렬

* 조건
  1. 현재 최적화가 다음 최적화 영향 안줌
  2. 현재 최적화가 모여서 전체 최적화가 됨


* 방법

  sort 함수 사용, Heapq, Class에서 정렬 구현
  
* 예시

  최솟값, 최댓값, n번째 수, 중앙값, 강의실 배정



## 위상정렬

* 사용하는 경우

  단방향 트리 + 추적

* 방법

  * indegree[자식]++

  * indegree[idx] == 0 이면 q에 넣기

  * indegree[자식]--;  indegree[자식] == 0 이면 q에 넣기  




# union -find 

* 사용하는 경우'

  네트워크 확인, 네트워크 갯수

* 방법

  * int[] parent 선언, parent[i] = i 초기화 

  * union, find 구현

  * find(a) != find(b) -> union(a,b)



# 이분 탐색

* 사용하는 경우

  * 시간초과

  * 조건 만족한 것중 최댓값 or 최솟값

```
// 초기값 주의
int s = x;
int e = y;

while(s <= e) {
	int m = (s+e) / 2;
	// 연산	
	...
	// 조건
	if() s = m + 1;
	else e = m - 1;
}

// return 값 주의(ans,s,e)
```





# 투포인터

* 사용하는 경우

  * 연속 수

    연속 합, 연속 짝수 확인

  * 두 수

    대칭 확인, 두 수 합



# DP

1. 사용하는 경우
   * 메모라이제이션
   * 최댓값, 최솟값 구하기

유형

1. 냅색

   비용 b이하 + 가치 최대

   ```java
   for(int i=1;i<=n;i++) {
   	for(int j=0;j<=n;j++) {
   		if(j-cost[i] < 0) continue;
   		dp[i][j] = Math.max(dp[i-1][j],dp[i-1][j-cost[i]]+value[i]);
   	}
   }
   ```

2. LIS

   ```java
   for(int i=1;i<n;i++) {
   	int min = 0;
   	for(int j=0;j<i;j++) {
           if(nums[j] >= nums[i]) continue;
   		max = Math.max(dp[j],max);
   	}
   	dp[i] = dp[j] + 1;
   }
   ```

3. LCS

   1. 최장 부분수열

      ```java
      for(int i=0;i<n;i++) {
      	for(int j=0;j<m;j++) {
      		if(str1.charAt(i) == str2.charAt(j)) dp[i-1][j-1] + 1;
      		else dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1]);
      	}
      }
      ```

   2. 최장 연속 부분수열

      ```java
      for(int i=0;i<n;i++) {
      	for(int j=0;j<m;j++) {
      		if(str1.charAt(i) == str2.charAt(j)) dp[i-1][j-1] + 1;	
      	}
      }
      ```

      



# 트리 최단 거리

## 다익스트라

* 사용하는 경우

  s(고정)-> e(여러개) 최단거리

* 방법

  pq, dist[] = INF, 정렬 기준

* 시간 복잡도 : O(ElogE)

```java
PriorityQueue<Edge> pq = new PriorityQueue<>();
Arrays.fill(dist,INF);

pq.add(new Edge{start,0});
visited[start] = true;

while(!q.isEmpty()) {
    Edge now = pq.poll();
    if(dist[now.idx] < now.dist) continue;
    
    for(Edge next : edges.get(now.idx)) {
        if(visited[next.idx]) continue;
        if(dist[next.idx] > now.dist + next.dist) {
            dist[next.idx] = now.dist + next.dist;
            
            pq.add(new Edge(next,idx,dist[next.idx]));
            visited[next.idx] = true;
        }
    }
}
```



## 플로이드 워셜

* 사용하는 경우

  s(여러개) -> e(여러개)

  시간 널럴할 때

* 방법

  a->c = Math.min(a->c, a->b+b->c)

* 시간 복잡도 O(V^3) 

```java
for(int i=1;i<=n;i++) {
    for(int j=1;j<=n;j++) {
        for(int k=1;k<=n;k++) {
            dp[j][k] = Math.min(dp[j][k],dp[j][i]+dp[i][k]);
        }
    }
}
```



## 최장신장트리

* 사용하는 경우

  순환 ㄴ +  다 연결하기 + 최소

* 방법

  pq, union-find

* 시간 복잡도 : O(ElogE)

```java
PriorityQueue<Edge> pq = new PriorityQueue<>();	// cost 오름차순
StringTokenizer st = new StringTokenizer(br.readLine());

for(int i=0;i<m;i++) {
    int a = Integer.parseInt(st.nextToken());
    int b = Integer.parseInt(st.nextToken());
    int c = Integer.parseInt(st.nextToken());
    pq.add(new Edge(a,b,c));
}

while(!pq.isEmpty()) {
 	Edge now = pq.poll();
    if(find(now.s) == find(now.e)) continue;
    union(now.s,now.e);
    ans += now.c;
}
```



# 구간합

* 사용하는 경우

  * 시간초과 나는 연속범위 합

* 유형

  * 1차원

    sum[i] = sum[i-1] + graph[i]

  * 2차원

    ```java
    // r1,c1 ~ r2,c2 degree만큼 더하기
    sum[r1][c1] += degree;
    sum[r2+1][c2+1] += degree;
    sum[r1][c2+1] -= degree;
    sum[r2+1][c1] -= degree;    
    
    
    // 행
    for(int i=1;i<n;i++) {
    	for(int j=0;j<m;j++) {
    		sum[i][j] += sum[i-1][j];
    	}
    }
    
    // 열
    for(int i=0;i<n;i++) {
    	for(int j=1;j<m;j++) {
    		sum[i][j] += sum[i][j-1];
    	}
    }
    
    // 결과 
    for(int i=0;i<n;i++) {
    	for(int j=0;j<m;j++) {
    		if(board[i][j] + sum[i][j] > 0) answer++;
    	}
    }
    ```

    

# 수학

## 최소공배수, 최대 공약수

```
public int euclid(int a, int b) {
	while(b != 0) {
		int r = a % b;
		a = b;
		b = r;
	}
	return a;
}

// 최소 공배수
int num = a * b / euclid(a,b);

// 최대 공약수
int num = euclid(a,b);
```

## 소수

1. 단일 소수 판별

   ```java
   public boolean checkPrime(int x) {
       for(int i=2;i<=(int)Math.sqrt(x);i++) {
       	if(x % i == 0) return false;
   	}
   
   	return true;
   }
   ```

2. 복수 소수 찾기

   ```java
   boolean[] notPrime = new boolean[x+1];
   for(int i=2;i<=(int)Math.sqrt(x);i++) {
       for(int j=2;j<=x/i;j++) {
           notPrime[i*j] = true;
       }
   }
   ```


## 반올림

```java
String.format(".2f",ans); // 2자리까지 반올림
double test = Math.round(ans*100)/100 // 2째 자리까지 반올림
double test = Math.ceil(ans*100)/100 // 2째 자리까지 올림
double test = Math.floor(ans*100)/100 // 2째 자리까지 내림
```



## 진수

```java
String binaryNum = Integer.toBinaryString(num);
int num = Integer.toparseInt(binaryNum,2);
```



# 주의

1. Integer 끼리 비교 주의

```
비교 대상 중 primitive type(int) 의 변수가 하나라도 있다면
== 연산자는 값으로 비교한다.

Boxed primitive 또는 Wrapper class(Integer) 끼리 비교 하는 경우
== 연산자는 각 객체의 주소 값을 비교 하게 된다.
값끼리의 비교는 equal 메소드를 사용해야한다.
```

2. 최댓값 초기값

   최댓값 초기값은 -1로 하자. 0값이 나오는 경우도 있으므로
