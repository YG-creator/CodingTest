# LEVEL 1 

## 1. 구현

* Collection(Map, Set, List)
  * [신고 결과 받기](https://programmers.co.kr/learn/courses/30/lessons/92334) - 

1. map, set 으로 구현

신고한사람 : 신고당한 사람(중복 ㄴ) / 신고당한 사람 : 신고 당한 횟수 / k번 이상 신고당한 사람들

2. id마다 신고당한 사람들 퇴출 된사람 수 세기

* 그래프
  * [키패드 누르기](https://programmers.co.kr/learn/courses/30/lessons/67256)

1. 키패드 그래프화 하기 - 수학(/,%)
2. 무조건 왼손 쓰는경우 -if
3. 무조건 오른손 쓰는 경우 -if
4. 거리 가까운손 쓰기 / 거리가 같으면 주로쓰는 손 사용 - 수학(abs), equals()



## 2. 문자열

* replaceAll()

  * [신규 아이디 추천](https://programmers.co.kr/learn/courses/30/lessons/72410)
* 대소문자 구분 ㄴ + 완탐
  * [숫자 문자열과 영단어](https://programmers.co.kr/learn/courses/30/lessons/81301)
  * [문자열 내 p와 y의 개수](https://school.programmers.co.kr/learn/courses/30/lessons/12916)


* substring()
  * [핸드폰 번호 가리기](https://school.programmers.co.kr/learn/courses/30/lessons/12948)

* 정렬 
  * [문자열 내 마음대로 정렬하기](https://programmers.co.kr/learn/courses/30/lessons/12915)
  * [문자열 내림차순으로 배치하기](https://school.programmers.co.kr/learn/courses/30/lessons/12917)

* 길이 + 숫자 여부 확인()
  * [문자열 다루기 기본](https://school.programmers.co.kr/learn/courses/30/lessons/12918)

* equals()  + 완탐
  * [서울에서 김서방 찾기](https://school.programmers.co.kr/learn/courses/30/lessons/12919)

* 문자열 -> 숫자
  * [문자열을 정수로 바꾸기](https://school.programmers.co.kr/learn/courses/30/lessons/12925)
* 아스키코드
  * [시저 암호](https://school.programmers.co.kr/learn/courses/30/lessons/12926)
* idx
  * [자연수 뒤집어 배열로 만들기](https://school.programmers.co.kr/learn/courses/30/lessons/12932)



## 3. 수학

다수 소수판별, 최대공약수 최소공배수, 연산 - 자료형

* 다수 소수 판별

  [소수 찾기](https://school.programmers.co.kr/learn/courses/30/lessons/12921) v

* 최대공약수 + 최소공배수 - 유클리드 v

  [최대공약수와 최소공배수](https://school.programmers.co.kr/learn/courses/30/lessons/12940) v

* 홀수, 짝수

  [가운데 글자 가져오기](https://programmers.co.kr/learn/courses/30/lessons/12903)

  [수박수박수박수박수박수?](https://school.programmers.co.kr/learn/courses/30/lessons/12922)

  [이상한 문자 만들기](https://school.programmers.co.kr/learn/courses/30/lessons/12930) v - 공란 처리 주의

  [짝수와 홀수](https://school.programmers.co.kr/learn/courses/30/lessons/12937)

  [콜라츠 추측](https://school.programmers.co.kr/learn/courses/30/lessons/12943) v - 자료형 주의

* 나머지 연산

  [모의고사](https://programmers.co.kr/learn/courses/30/lessons/42840)

  [나머지가 1이 되는 수 찾기](https://programmers.co.kr/learn/courses/30/lessons/87389)

  [나누어 떨어지는 숫자 배열](https://programmers.co.kr/learn/courses/30/lessons/12910)
  
* 연산 - 자료형 주의

  [실패율](https://programmers.co.kr/learn/courses/30/lessons/42889) - 나누기 + 정렬

  [평균 구하기](https://school.programmers.co.kr/learn/courses/30/lessons/12944) - 나누기 

  [행렬의 덧셈](https://school.programmers.co.kr/learn/courses/30/lessons/12950) - 덧셈
  
  [x만큼 간격이 있는 n개의 숫자](https://school.programmers.co.kr/learn/courses/30/lessons/12954) - 곱셈 

  [정수 제곱근 판별](https://school.programmers.co.kr/learn/courses/30/lessons/12934) v - 제곱, 제곱근

* 약수

  [약수의 개수와 덧셈](https://programmers.co.kr/learn/courses/30/lessons/77884) - 약수 + 홀짝

  [약수의 합](https://school.programmers.co.kr/learn/courses/30/lessons/12928)
  
* 자릿수

  [자릿수 더하기](https://school.programmers.co.kr/learn/courses/30/lessons/12931) - 완탐

  [하샤드 수](https://school.programmers.co.kr/learn/courses/30/lessons/12947) - 자릿수 + 나머지



## 4. 자료구조

* Stack
  
  LIFO
  
  [크레인 인형뽑기 게임](https://programmers.co.kr/learn/courses/30/lessons/64061)
  
* map

  갯수

  [완주하지 못한 선수](https://programmers.co.kr/learn/courses/30/lessons/42576)

* set

  중복ㄴ

  [폰켓몬](https://programmers.co.kr/learn/courses/30/lessons/1845)



## 5. 그리디

* 정렬

  [체육복](https://programmers.co.kr/learn/courses/30/lessons/42862) v

  [예산](https://programmers.co.kr/learn/courses/30/lessons/12982)

  [두 정수 사이의 합](https://programmers.co.kr/learn/courses/30/lessons/12912)

  [정수 내림차순으로 배치하기](https://school.programmers.co.kr/learn/courses/30/lessons/12933)



## 6. 완전탐색

[로또의 최고 순위와 최저 순위](https://programmers.co.kr/learn/courses/30/lessons/77484)





## 7. 순열 조합

* 순열

  [단체사진 찍기](https://programmers.co.kr/learn/courses/30/lessons/1835) - 전역변수 초기화 해줘야 됨 v

* 조합
  * [소수 만들기](https://programmers.co.kr/learn/courses/30/lessons/12977)
  * [두 개 뽑아서 더하기](https://programmers.co.kr/learn/courses/30/lessons/68644)



## 8. 구현

[K번째수](https://programmers.co.kr/learn/courses/30/lessons/42748)

Array Index

1. a~b 번째 수 자르기
2. 오름차순 정렬
3. n번째 수 출력

[2016년](https://programmers.co.kr/learn/courses/30/lessons/12901) v

구현 

1. 달마다 일 구현
2. 총 일수 구하기
3. 차이 일수 구하기
4. 요일 구하기

[최소직사각형](https://programmers.co.kr/learn/courses/30/lessons/86491) 

구현

1. 각 직사각형 최댓값 최솟값 구하기
2. 최댓값을 세로, 최소값을 가로로 고정함
3. 이전 세로 가로랑 비하기 -> 최댒값으로 초기화
4. 가로 x 세로 출력

[부족한 금액 계산하기](https://programmers.co.kr/learn/courses/30/lessons/82612)

구현

1. 총가격 = 1~n합 * 가격 
2. 가지고 있는 돈이랑 비교
   1. 안부족하면 0 출력
   2. 부족하면 차이만큼 출력

[같은 숫자는 싫어](https://programmers.co.kr/learn/courses/30/lessons/12906)

연속 같은 숫자 확인 

```
1. 이전거랑 다른게 나올때만 추가
1. 이전거 초기화
```



[제일 작은 수 제거하기](https://school.programmers.co.kr/learn/courses/30/lessons/12935) v

제일 작은수 찾기 -> 제일 작은수와 같으면 continue / 다르면 넣기

제일 작은수가 여러개 인경우를 고려안해서 틀림



[직사각형 별찍기](https://school.programmers.co.kr/learn/courses/30/lessons/12969)

반복문 행, 열





# LEVEL 2

## 1. 문자열

[문자열 압축](https://programmers.co.kr/learn/courses/30/lessons/60057)

1. 1~n/2 단위로 자르기
2. 숫자(반복된 숫자, 1은 안해도됨)+반복된 문자 
3. 최소길이 구하기

[1차 뉴스 클러스터링](https://programmers.co.kr/learn/courses/30/lessons/17677)

1. 다 소문자로 변환 - toLowerCase()
2. 2글자 씩 자르기 - substring()
3. 자른거 map에 넣기 - map(str, cnt)
4. 둘다 공집합이면 1 출력하기 - map.isEmpty()
5. 교집합, 합집합, 유사도 구하기 - Math.min(), Math.max()
6. 유사도 * 63356 곱하기 - 자료형

[최댓값과 최솟값](https://school.programmers.co.kr/learn/courses/30/lessons/12939)

문자열, 최대 최소

[JadenCase 문자열 만들기](https://school.programmers.co.kr/learn/courses/30/lessons/12951) v

1. 앞글자가 공백이면
   1. 영어면 대문자
   2. 영어 아니면 그대로
2. 나머지 글자 그대로





## 2. 수학

[멀쩡한 사각형 ](https://programmers.co.kr/learn/courses/30/lessons/62048) v

1.  최대공약수 구하기
2.  w * h - (w + h - 최대공약수) 출력

[기능개발](https://programmers.co.kr/learn/courses/30/lessons/42586)

1. 처리시간 구하기 - Math.ceil()
2. 전거보다 큰 경우  /  작거나 같은 경우  /  마지막거  - pq

[소수 찾기](https://programmers.co.kr/learn/courses/30/lessons/42839)

순서ㄴ 순열 + 단일 소수판별

1. 중복 ㄴ 숫자 순열 만들기 - dfs, set
2. 단일 소수판별

[숫자 블록](https://school.programmers.co.kr/learn/courses/30/lessons/12923) vv

소수 찾기

1. 시작점~끝점 완전탐색
   1. n미만의 최대 약수 찾기
      1. 2~n제곱근의 수로 나눠떨어짐
      2. n / i  <= (int)1e7 
      3. 없으면 1출력

[N개의 최소공배수](https://school.programmers.co.kr/learn/courses/30/lessons/12953)

완전탐색 + 최소공배수

[행렬의 곱셈](https://school.programmers.co.kr/learn/courses/30/lessons/12949)

수학

```java
answer[i][j] += arr1[i][k] * arr2[k][j];
```



[n^2 배열 자르기](https://school.programmers.co.kr/learn/courses/30/lessons/87390)

몫,나머지 구하기 + arr idx

1. 행, 열 구하기

2. 최댓값(행+1,열+1) 넣기 

   

## 3. 구현

[오픈채팅방](https://programmers.co.kr/learn/courses/30/lessons/42888)

1. 신고한 사람 : 신고당한 사람 
2. 신고당한 사람 : 신고당한 횟수 
3. 퇴출 된 사람 list
4. 신고한 사람 : 신고당한 사람 +  퇴출된사람 list -> 퇴출당한 사람 수 세기

[행렬 테두리 회전하기](https://programmers.co.kr/learn/courses/30/lessons/77485) v

그래프 회전

1. 그래프 만들기
2. 반복
   1. 테두리 최솟값 구하기
   2. 테두리 회전하기 - 방향 반대로해서 구하기, 맨마지막값은 저장해놔야됨

[튜플](https://programmers.co.kr/learn/courses/30/lessons/64065) v

HashMap

1. 튜플갯수 세기
2. 숫자만 뽑아내기
3. 숫자 갯수 세기
4. 많은것부터 출력 , n-i 만큼 갯수 빼기 

[더 맵게](https://programmers.co.kr/learn/courses/30/lessons/42626)

PriorityQueue - 최솟값

1. 첫번째 작은거 , 두번째 작은거 구하기 - pq
2. 합치기 
3. 최솟값이 k이상인지 확인하기 - pq

[거리두기 확인하기](https://programmers.co.kr/learn/courses/30/lessons/81302)

1. P위치 list에 담기
2. P간 거리 구하기
3. 맨해튼 거리 2이하인거 찾기
   1. 거리가 1이면 0출력
   2. 거리가 2이면 다 막혔는지 확인
      1. 직선 
      2. 대각선
   3. 거리가 2초과면 continue

[프린터](https://programmers.co.kr/learn/courses/30/lessons/42587) v

pq

1. 최댓값 출력
2. 최댓값과 같고 idx도 같으면 출력

[예상 대진표](https://programmers.co.kr/learn/courses/30/lessons/12985)

while()

1. 2 나누기 -> 올림 ,  cnt++
2. 둘이 같으면 끝

[스킬트리](https://school.programmers.co.kr/learn/courses/30/lessons/49993)

구현 - Map(스킬, idx)

안되는 경우 

```
1. 스킬은 다 있는데 순서가 틀림
1. 스킬 하나 있는데 앞에 배워야 할 스킬이 없음
```

[교점에 별 만들기](https://school.programmers.co.kr/learn/courses/30/lessons/87377) v

구현 - 그래프

1. 교점 구하기 
   1. 평행
   2. 교점
2. 최소,최대 x, y 구하기
3. 최소 사각형 그리기
   1. 교점은 *
   2. 나머지 .





## 4. bfs,dfs

* 덩어리 갯수 세기

  [카카오 프렌즈 컬러링북](https://programmers.co.kr/learn/courses/30/lessons/1829)

* 최단 거리

  [게임 맵 최단거리](https://programmers.co.kr/learn/courses/30/lessons/1844)

  [빛의 경로 사이클](https://school.programmers.co.kr/learn/courses/30/lessons/86052) vv

* 연결

[전력망을 둘로 나누기](https://school.programmers.co.kr/learn/courses/30/lessons/86971) v

완전탐색 + bfs

1. 다 연결하기

2. 한개 선만 끊기(완전탐색)

3. 이어진 노드 갯수세기(bfs)

4. 노드 갯수 차이 최솟값 구하기

[쿼드압축 후 개수 세기](https://school.programmers.co.kr/learn/courses/30/lessons/68936)

완전탐색(dfs)

1. 다 같은지 확인
   1. 같으면 해장 숫자 갯수 증가
   2. 다르면 쪼개기(dfs)



## 5. 조합,순열

[단체사진 찍기](https://programmers.co.kr/learn/courses/30/lessons/1835)

1. 8명 순열 - 백트래킹, map, array
2. 순열마다 조건 확인하기 - 완전탐색

[타겟넘버](https://programmers.co.kr/learn/courses/30/lessons/43165)

완전탐색(dfs)

1. +,- 둘중 하나 선택
2. 연산 결과가 target과 같은지 확인 -> 같으면 cnt++

[메뉴 리뉴얼](https://programmers.co.kr/learn/courses/30/lessons/72411) vv

조합 + map

1. 각 주문에서 n개 뽑기
   1. 뽑은거 map에 넣기
   2. map value최댓값 확인
      1. 최댓값이 2보다 작으면 pass 
      2. 최댓값과 같은 value를 가진 key들을 추가

[카카오 인턴 수식 최대화](https://programmers.co.kr/learn/courses/30/lessons/67257)

순열+연산+절댓값+최댓값

1. 연산 순서 정하기
2. 숫자, 연산 분리하기
3. 연산 순서대로 연산하기
4. 연산결과 절댓값 최댓값 구하기

[후보키](https://programmers.co.kr/learn/courses/30/lessons/42890) vv

조합, set, contains

1. 유일성 -set
2. 최소성- containsAll

​		유의점 : 인수에 int[] 를 다른곳에 삽입할경우 clone 써줘야됨

[피로도](https://school.programmers.co.kr/learn/courses/30/lessons/87946)

완전탐색

1. 중복ㄴ 순열
2. 순열마다 정복 가능한 던전수 세기
3. 최댓값 출력

[N-Queen](https://school.programmers.co.kr/learn/courses/30/lessons/12952) vv

중복 ㄴ 순열 + 직선 체크

주의 : 메모리(100만), 시간초과(1e9)



## 6. n진법

[124 나라의 숫자](https://programmers.co.kr/learn/courses/30/lessons/12899)

10진법 -> 3진법 -> 124로 숫자 변환

[3진법 뒤집기](https://programmers.co.kr/learn/courses/30/lessons/68935)

10진법 -> 3진법 -> 10진법

[이진 변환 반복하기](https://school.programmers.co.kr/learn/courses/30/lessons/70129) 

완전탐색 + 문자열 + 이진법으로 변환

1. 0 갯수 세기
2. 0 없애기
3. 문자열 길이 구하기
4. 길이 -> 2진법으로 변환

s.replace()    ->  s = s.replace() 로 해야됨 

Integer.toBinaryString()

[다음 큰 숫자](https://school.programmers.co.kr/learn/courses/30/lessons/12911) v 

완전탐색 + 이진수 변환

1. 이진수로 변환
2. n보다 큰수 중 1의 갯수 같은거 찾기
   1. n보다 큰수 완전탐색
   2. 1의 갯수 세기
   3. 1의 갯수 비교

틀린 이유 : 

완전탐색 안하고 규칙성 찾다가 틀림 

n이 1000000 이하라서 완전탐색 가능 

완전탐색부터 생각해라



[k진수에서 소수 개수 구하기](https://school.programmers.co.kr/learn/courses/30/lessons/92335)

k진수로 변환 + 소수판별

자료형 주의



## 7. 자료구조

* Stack

  [짝지어 제거하기](https://programmers.co.kr/learn/courses/30/lessons/12973)

  stack

  1. 비어있으면 add
  2. 안비어 있는경우
     1. 맨위에거랑 같으면 pop
     2. 다르면 add
  3. stack이 비어있는지 확인
     1. 비어있으면 1출력
     2. 안비어있으면 0출력

  [괄호 변환](https://programmers.co.kr/learn/courses/30/lessons/60058)

  dfs + Stack

  1. 균형잡힌지 확인
  2. 올바른지 확인
  3. 조건에 맞게 출력

  [괄호 회전하기](https://school.programmers.co.kr/learn/courses/30/lessons/76502)

  괄호회전(substring) + Stack(LIFO)

  괄호 3종류 

  1. 여는거면 add
  2. 닫는 거면 이전게 같은 괄호 종류여야됨
     1. 같으면 pop
     2. 다르면 false
  3. 스택이 비어있는지 확인
     1. 비어있으면 true
     2. 안비어있으면 false

  [올바른 괄호](https://school.programmers.co.kr/learn/courses/30/lessons/12909)

  Stack

  1. ( 면 넣기
  2. ) 
     1. stack이 비어 있으면 return false
     2. 있으면 pop()
  3. stack이 비어있는지 확인
     1. 비어있으면 return true
     2. 안비어 있으면 return false

  

* Map 

  [주차 요금 계산](https://school.programmers.co.kr/learn/courses/30/lessons/92341?language=java)

  문자열 + map + TreeMap(key 오름차순)

## 8. 그리디

[전화번호 목록](https://programmers.co.kr/learn/courses/30/lessons/42577) vv

그리디(정렬)

1. 정렬하기
2. 앞 뒤 접두사 있는지 확인
   1. 접두사면 return false
   2. 아니면 continue

[가장 큰 수](https://programmers.co.kr/learn/courses/30/lessons/42746) vv

그리디

1. 숫자 -> 문자열
2. 문자열 내림차순 정렬(a+b, b+a 비교) v
3. 큰거부터 더하기

[조이스틱](https://programmers.co.kr/learn/courses/30/lessons/42860)vv

그리디 v

1. 위아래 최단거리 - 알파벳-'A'  vs 'Z'+1 - 알파벳
2. 오왼 최단거리 v

[큰 수 만들기](https://school.programmers.co.kr/learn/courses/30/lessons/42883) vv

그리디 - 정해진 범위 최댓값 찾기

1. 반복
   1. idx ~ idx+k 에서 최댓값 찾기
   2. str += 최댓값
   3. idx = i+1 

[구명보트](https://school.programmers.co.kr/learn/courses/30/lessons/42885) v

그리디

1. 정렬
2. 2명 태우기
   1. 한계 이하면 2명
   2. 한계 초과면 최대만 태우기

[H-Index ](https://school.programmers.co.kr/learn/courses/30/lessons/42747)v

그리디

1. 정렬
2. i~n 갯수 세기
3. citations[i] >= h 이면 출력, break

[최솟값 만들기](https://school.programmers.co.kr/learn/courses/30/lessons/12941)

그리디

1. 정렬하기
2. 최솟값 * 최댓값 더하기



## 9. 이분탐색

[순위 검색](https://programmers.co.kr/learn/courses/30/lessons/72412)

map, 완전탐색, 이분탐색

1. 선택 or 선택안하기 완전탐색
2. 항목 : 점수들 map 구현
3. n 이상인 점수 갯수 구하기 - 이분탐색\\\\\\\\\\\



## 10. 최단거리

[배달](https://school.programmers.co.kr/learn/courses/30/lessons/12978)

플로이드 와샬

1. 최단거리 구하기
2. 1->i 중 k이하인거만 세기





## 11. 완전탐색

[점프와 순간 이동](https://school.programmers.co.kr/learn/courses/30/lessons/12980) v

완전탐색 top down

완전탐색 bottom up -> 시간초과

dp -> 메모리 초과, 시간초과

완전탐색 top down -> 통과

[모음 사전](https://school.programmers.co.kr/learn/courses/30/lessons/84512)

완전탐색 bottom up

[줄 서는 방법](https://school.programmers.co.kr/learn/courses/30/lessons/12936) v

완전탐색 bottom up

팩토리얼 , 몫, 나머지 

1. 시작 숫자가 1이므로 k--

2. 다 뽑을 때까지 반복
   1. (n-1-depth)! 구하기
   2. 남은 숫자중 k/(n-1-depth)! 번째 숫자 넣기
   3. k %= (n-1-depth)!
   4. depth++ 



## 12. DP

[2 x n 타일링](https://school.programmers.co.kr/learn/courses/30/lessons/12900)

dp

dp[i] = dp[i-1] + dp[i-2]

[3 x n 타일링](https://school.programmers.co.kr/learn/courses/30/lessons/12902)

dp

![image-20220713152459816](md-images/image-20220713152459816.png)

[가장 큰 정사각형 찾기](https://school.programmers.co.kr/learn/courses/30/lessons/12905) v

2차 dp

```java
dp[i][j] = Math.min(Math.min(dp[i-1][j],dp[i][j-1]),dp[i-1][j-1])
// 1행 or 1열만 있을 때 주의
```

[땅따먹기](https://school.programmers.co.kr/learn/courses/30/lessons/12913)

2차 dp

1. dp에 초기값 넣기
2. 전거 다른열 중 최댓값 구하기
3. 고른거랑 최댓값 더해서 dp에 넣기
4. 마지막 dp 중 최댓값 출력

주의 : 초기값



[멀리 뛰기](https://school.programmers.co.kr/learn/courses/30/lessons/12914)

1차 dp

1. 초기값 설정
2. dp[i] = dp[i-1] + dp[i-2]



[피보나치 수](https://school.programmers.co.kr/learn/courses/30/lessons/12945)

완전탐색(바텀 업) + 1차 dp

dp[i] = dp[i-1] + dp[i-2]



## 13. 비트

[2개 이하로 다른 비트](https://school.programmers.co.kr/learn/courses/30/lessons/77885) v

비트 연산 - 규칙성

1. 짝수 : 1을 더함
2. 홀수 v
   1. 0이 없는 경우 : 10 그대로 두고 그뒤를 모두 1로 바꾸기
   2. 0이 있는 경우 : 제일 앞 0을 1로 , 그 뒤의 1중 맨앞에 있는 1을 0으로 바꾸기



## 14. 투포인터

[숫자의 표현](https://school.programmers.co.kr/learn/courses/30/lessons/12924)

투포인터

1. 합이 같으면 cnt++, sum-num[s], s++
2. 합 < n 이면 e++, sum + num[e]
3. 합 > n 이면 sum - num[s], s++



# LEVEL 3

## 1. 문자열

- [[1차] 추석 트래픽](https://school.programmers.co.kr/learn/courses/30/lessons/17676) vv

  1. 문자열 -> 숫자(시각) v

     자료형 주의 - 소수는 Double로 하자

  2. 시간대 안 포함 여부 확인(시작,끝) 

     안포함하는 경우를 if로 하자

  3. 최댓값 구하기

## 2. BFS, DFS

* [가장 먼 노드](https://school.programmers.co.kr/learn/courses/30/lessons/49189)
  1. 간선 연결하기
  2. 1에서 부터 최단거리 구하기(bfs)
  3. 최대거리 구하기
  4. 최대거리를 가진 노드갯수 구하기
* [네트워크](https://school.programmers.co.kr/learn/courses/30/lessons/43162)
  1. 간선 연결하기
  2. bfs로 덩어리갯수 세기

## 3. DP

* N으로 표현 v

  set + dp

  1. set 1~8개 선언, 초기값 넣기

  2. i번째 set = (j번째 set 과 i-j 번째 set의 사칙연산) 합집합 + N을 i번 반복한 숫자
  3. 최솟값 찾기
  4. 8넘어가면 -1 출력 

* [정수 삼각형](https://school.programmers.co.kr/learn/courses/30/lessons/43105)

  2차 dp

  1. 초기값
  2. dp
     1. 맨앞 : `dp[i][j] = dp[i-1][j] + triangle[i][j]`
     2. 중간 : `dp[i][j] = Math.max(dp[i-1][j],dp[i-1][j+1]) + triangle[i][j]`
     3. 맨뒤 : `dp[i][j] = dp[i-1][j+1] + triangle[i][j]`
  3. 최댓값 구하기 : `Math.max(answer,dp[n-1][i])`

* [등굣길](https://school.programmers.co.kr/learn/courses/30/lessons/42898) vv

  최단거리 경로 갯수(2차 dp)

  1. 물웅덩이 그래프로 구현
  2. 초기화 시작점 1
  3. 2차 dp `dp[i][j] = (dp[i-1][j] + dp[i][j-1])`
     1. 조건(물웅덩이 ㄴ)
     2. 범위

  ! 주의 : bfs는 최단거리, 덩어리갯수 구하기

  ​		   최단거리 갯수는 dp로 하자

## 4. 플로이드 와샬

* [순위](https://school.programmers.co.kr/learn/courses/30/lessons/49191) v
  1. 그래프로 승패 구현
     1. 이기면 1
     2. 지면 -1
  2. 서로 승부안했어도 승패 아는거 구현(플로이드 와샬) v
     1. `graph[i][k] == 1 && graph[k][j] == 1 -> graph[i][j] = 1, graph[j][i]=-1`
     2. `graph[i][k] == -1 && graph[k][j] == -1 -> graph[i][j] = -1, grpah[j][i]=1`
  3. 승패 갯수가 n-1인거 세기 



## 5. 그리디

* [디스크 컨트롤러](https://school.programmers.co.kr/learn/courses/30/lessons/42627) vv
  1. 정렬
     1. 소요시간 오름차순
     2. 시작시간 오름차순 v
  2. 전체 작업시간 구하기 vv
     1. 시작시간이 실제시간 이하인 경우
        1. 실제시간 += 소요시간
        2. 전체 작업시간 += 실제시간-시작시간
        3. 수행한 작업 제거
        4. 다음 거
     2. 초과인 것만 남으면 실제시간++
  3. 전체 작없시간 평균 구하기

## 5. 완전탐색

* [단어 변환](https://school.programmers.co.kr/learn/courses/30/lessons/43163) v

  완전탐색(바텀업)

  1. target 단어 있는지 확인
     1. 없으면 0 출력
     2. 있으면 한글자씩 바꾸기(dfs)
        1. target 단어가 되면 최솟값 구하기
        2. 없으면 한글자만 다른 단어 선택하기, cnt++
  
* [다단계 칫솔 판매](https://school.programmers.co.kr/learn/courses/30/lessons/77486) v

  dfs

  1. map 구현
     1. 자신, idx
     2. 자신, 부모
  2. 부모에게 10프로 이익주기(dfs) v
     1. 부모 없을때까지 반복
        1. 부모 10프로 주기
        2. 나머지 자신의 재산에 넣기
        3. 자신 -> 부모, 이익 -> 이익/10   

* [여행경로 ](https://school.programmers.co.kr/learn/courses/30/lessons/43164) v

  dfs

  1. dfs
     1. 티켓 다 쓰기(중복ㄴ 조합) v
     2. 경로가 여러개면 정렬
  2. String[] 형태로 변환

## 6. 자료구조

1. 우선순위 큐

   * [이중우선순위큐](https://school.programmers.co.kr/learn/courses/30/lessons/42628)

     최댓값 ,최솟값

     1. 삽입
     2. 최댓값 삭제
     3. 최솟값 삭제
     4. 다 한후 출력
        1. 비어있으면 0,0 출력
        2. 안비어 있으면 최댓값, 최솟값 출력

     주의 : `pq.remove(요소)` 로 요소 삭제 가능

   * [[1차] 셔틀버스 ](https://school.programmers.co.kr/learn/courses/30/lessons/17678) vv

     최솟값

     1. 시간 삽입
     2. 버스 태우기 v
     
        1. 빠른 시간부터 태우기(pq)
        2. 시간, 인원수 제한(if 대소비교)
        3. 다음버스 출발(+=t)
        4. 다 탔으면 종료(while(!pq.isEmpty()))
     

2. Map

   * [베스트앨범](https://school.programmers.co.kr/learn/courses/30/lessons/42579) v

     map + 정렬

     1. 장르별 총재생수 내림차순 정렬
        1.  재생수 내림차순
        2. 고유번호 오름차순
        3. 장르별 2개  / 1개면 1개 출력 v



7. 슬라이딩 윈도우

   * [광고 삽입](https://school.programmers.co.kr/learn/courses/30/lessons/72414)

     슬라이딩 윈도우 + 완전탐색

     1. String to int(string parsing)
        1. 동영상 재생 시간
        2. 광고 시간
        3. logs
     2. logs로 누적 동영상 구하기(완전탐색)
     3. 최대 누적 구하기(슬라이딩 윈도우 + 완전탐색)
        1. 1초씩 이동하므로 끝에만 빼고 더하기

8. 누적합

   * [파괴되지 않은 건물 ](https://school.programmers.co.kr/learn/courses/30/lessons/92344?language=java)v

     1. 변화량 입력 

        ```java
        sum[r1][c1] += degree;
        sum[r1][c2+1] += (degree * -1);
        sum[r2+ 1][c1] += (degree * -1);
        sum[r2+1][c2+1] += degree;
        ```

     2. 누적합 구하기

        1. 상하

           ```java
           sum[i][j] += sum[i-1][j]
           ```

        2. 좌우

           ```java
           sum[i][j] += sum[i][j-1]
           ```

     3. 내구도 구하기(sum + board)

     4. 파괴되지 않은거 건물 세기(내구도 1이상)

# 주의점

1. 규칙 찾기
   1. 직접 하나씩 해봐라
   2. 정렬 or dp
2. 나누기 연산시 분모 주의

3. 소수 자료형 - Double로 하자

4. 안포함하는 경우를 if로 하자

5. bfs는 최단거리, 덩어리갯수 구하기 / 최단거리 갯수는 dp로 하자

6. `pq.remove(요소)` 로 요소 삭제 가능

7. 슬라이딩 윈도우 : 구간길이가 일정 & 1씩 이동 & 누적합이 필요할 경우 -> 양끝을 더하고 빼기
