* 1차 DP

dp[i] = dp[i-1] + dp[i-2]  :  15624 피보나치수 7 , 1904 01타일, 11726 2xn 타일링, 

dp[i] = dp[i-1] + dp[i-2] + dp[i-3] :   9095 1,2,3 더하기

idp[a] = dp[b] + 1 : 11053 가장 긴 증가하는 부분 수열

dp[i] += dp[i] + dp[i-j] : 2293 동전1

j는 i 이하 && dp[i] = Math.max(dp[i],dp[i-j]+arr[j] )  : 11052 카드구매하기



* 2차 DP : 

10844 쉬운 계단 수 , 1149 RGB 거리



* 스냅백 

12866 평범한 배낭, 7579 앱



* 3차 dp - 2602 돌다리 건너기



* LCS

```java
if(a.charAt(i-1) == b.charAt(j-1)) {
	LCS[i][j] = LCS[i-1][j-1] + 1;
} else {
	LCS[i][j] = Math.max(LCS[i-1][j], LCS[i][j-1]);
}
```

9251 LCS, 



* 팰린드롬 - 대칭수

```
1 글자 - 무조건 대칭
2 글자 - 두글자가 같아야 대칭
3 글자 이상 - 맨처음과 맨끝이 같고 그사이에 있는 수가 대칭수이면 대칭
```

10942 팰린드롬?



* 그래프와 DP

1520 내리막 길

```java
// 방문처리
//처음에 Top-Down 방식으로 수정하면서, 따로 visited 배열을 만들지 않고 dp배열의 0값을 미방문으로 인식하고 구현했다.
//그러나 0일 경우에, 연결이 도착점과 연결이 안된 것인지 탐색을 안한것인지 구별하지못해 탐색을 했음에도 도착점과 연결이 안된 경로를 재탐색하기 때문에 시간초과가 난다.
//결론적으로 다시 visited 배열로 방문을 체크를 했다.
```





# 주의점

n 이 3자리수면 array 가능 

나머지 연산 dp 값 넣을 때마다

