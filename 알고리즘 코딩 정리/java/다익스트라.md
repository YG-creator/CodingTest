# 다익스트라



## 개념

* 사용하는 경우 : 1->n 까지 노드간 최단거리

* 최소힙 우선순위 큐 사용

```java
PriorityQueue<Node> queue = new PriorityQueue<>();
```

* 과정

  1. 출발노드 설정 

  2. 최단거리 테이블 초기화 (Arrays.fill(dist,INF), dist[start] = 0)

  3. 방문하지 않은 노드중에서 최단거리가 가장 짧은 노드 선택(if(!visited[next]  &&  dist[next]  >  dist[now] + weight 일때 우선순위 큐에 (next, dist[now] + weight)추가))

  4. 해당 노드를 거쳐 다른 노드로 가는 비용을 계산하여 테이블 갱신 (dist[next] = dist[now] + weight)

  5. 3번 4번 과정 반복

* 시간복잡도 : O((V+E)logV)



## 문제

1753 최단경로 

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.PriorityQueue;
import java.util.StringTokenizer;


class Node implements Comparable<Node>{
    int end, weight;

    public Node(int end, int weight){
        this.end = end;
        this.weight = weight;
    }

    @Override
    public int compareTo(Node o) {
        return weight - o.weight;
    }
}

public class Main {
    private static final BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    private static final int INF = 100_000_000;
    static int v,e,k;
    static List<Node>[] list;
    static int[] dist;


    public static void main(String[] args) throws IOException {
        StringTokenizer st = new StringTokenizer(br.readLine());
        v = Integer.parseInt(st.nextToken());
        e = Integer.parseInt(st.nextToken());
        k = Integer.parseInt(br.readLine());
        list = new ArrayList[v + 1];
        dist = new int[v + 1];

        Arrays.fill(dist, INF);

        for(int i = 1; i <= v; i++){
            list[i] = new ArrayList<>();
        }
        // 리스트에 그래프 정보를 초기화
        for(int i = 0 ; i < e; i++){
            st = new StringTokenizer(br.readLine());
            int start = Integer.parseInt(st.nextToken());
            int end = Integer.parseInt(st.nextToken());
            int weight = Integer.parseInt(st.nextToken());
            // start에서 end로 가는 weight 가중치
            list[start].add(new Node(end, weight));
        }

        StringBuilder sb = new StringBuilder();
        // 다익스트라 알고리즘
        dijkstra(k);
        // 출력 부분
        for(int i = 1; i <= v; i++){
            if(dist[i] == INF) sb.append("INF\n");
            else sb.append(dist[i] + "\n");
        }
        System.out.println(sb);
    }

    private static void dijkstra(int start){
       PriorityQueue<Node> queue = new PriorityQueue<>();
       boolean[] check = new boolean[v + 1];
       queue.add(new Node(start, 0));
       dist[start] = 0;

       while(!queue.isEmpty()){
           Node curNode = queue.poll();
           int cur = curNode.end;

           if(check[cur] == true) continue;
           check[cur] = true;

           for(Node node : list[cur]){
               if(dist[node.end] > dist[cur] + node.weight){
                   dist[node.end] = dist[cur] + node.weight;
                   queue.add(new Node(node.end, dist[node.end]));
               }
           }
       }
    }
}
```



1504 특정한 최단경로

```java
최단거리이므로 다익스트라 사용

두가지 경우 고려(다익스트라 여러번 사용)
1. 1->v1->v2->n
2. 2->v2->v1->n

주의점 : INF 값 주의(20000 x 1000로 설정함)
```



4485 녹색 옷 입은 애가 젤다지?

```java
0,0 -> n-1,n-1 최단거리
int[] dx, int[] dy 설정
dist[0][0] = graph[0][0] 설정 후 다익스트라 
```

 

# 플로이드 워셜



## 개념

* 가능한 모든 노드의 최단거리(방문처리 필요 ㄴㄴ)
* 사용하는 경우 : 2차 그래프 최단거리
* 시간 복잡도 : O(V^3)  -> V가 1000이하 간선일 때 사용 가능
* 원리 : Dab = min (Dab,Dak+Dkb)
* 과정
  1. 2차 graph 설정(모두 INF로 i,i는 0으로)
  2. for(int k = 1; k<=n; k++) Dab = min (Dab,Dak+Dkb) 갱신



## 문제

* 11404 플로이드

```java
모든 경로의 최소값 구하기
```



- LEVEL3 합승 택시 요금

```java
s->x + x -> a + x -> b 최솟값 구하기
1. 다익스트라 여러번하기	-> 효율성 ㄴㄴ
2. 플로이드 와샬	-> n이 1000이하라서 효율성 oo
```



