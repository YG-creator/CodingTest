# 완전 탐색

완전 탐색

* for문

  

# 문자열

* substring()

  ```java
  String temp = str.substring(시작idx, 끝idx+1);
  ```

* split()

  ```java
  String[] str = str.split("문자열");	// 문자열
  String[] str = str.split("//특수문자열");	// 특수문자열
  String[] str = str.split("문자열|문자열")	// 여러 문자열
  ```

* replaceAll()

  ```java
  // ~제외 제거 [^문자]
  str = str.replaceAll("[^a-z]",""); // a-z를 제외 제거
  str = str.replaceAll("[^a-z0-9-_.]",""); // 알파벳, 숫자, -_. 제외 제거
  
  // 처음, 마지막거 제거	^[문자]  ,  [문자]$
  str = str.replaceAll("^[.]",""); // 처음. 제거
  str = str.replaceAll("[.]$",""); // 마지막. 제거
  str = str.replaceAll("^[.]|[.]$", ""); // 처음, 마지막. 모두 제거  
  
  // 여러 문자 제거  |  띄어쓰기 ㄴㄴ
  str = str.replaceAll("[문자]|[문자]", ""); 
  
  // 연속 반복 치환
  str = str.replaceAll("[.]{2,}","."); // 연속2개 이상 -> 1개
  ```

* charAt()

  ```java
  char c = s.charAt(idx);
  ```

* trim() : 양 끝 공백 제거

  ```java
  String str = str.trim();
  ```

* 아스키 코드

  ```java
  int index = 'a';			 // 아스키 코드
  char temp = (char)index; 	 // 문자
  int num = Character.getNumericValue(c);	// '숫자문자' -> 숫자
  ```

* 대소문자

  ```java
  // 문자열
  String str = "AsD";
  str.toLowerCase();	// 소문자
  str.toUpperCase();	// 대문자
  
  // 문자
  char = 'a';
  Character.toLowerCase(c);	// 소문자
  Character.toUpperCase(c);	// 대문자
  ```

* 확인

  ```java
  Character.isDigit(c);			// 숫자
  Character.isAlphabetic(c);		// 알파벳
  Character.isUpperCase(c);		// 대문자
  Character.isLowerCase(c);		// 소문자
  ```


* 같은지 확인 : equals()

  ```java
  "a".equals("b") // false
  "a".equals("a") // false
  ```

* 비교 compareTo() 

  대소문자 같아야 비교 가능

  ```java
  "a".compareTo("b")  // -1
  "a".comapreTo("a")  // 0
  "b".comapreTo("a")  // 1
  ```

* 길이 : length()

  ```java
  "a".length() // 1
  ```

* 인덱스 : indexOf()

  ```java
  "asdfa".indexOf("a") // 0
  ```

  

# 자료구조

## arr

같은 자료형, 크기 정해짐

## List

같은 자료형, 크기 모름



## Heapq

정렬



## Stack

LIFO, 오큰수



## Queue

FIFO, 무게제한 다리건너기



## Map

* 개념

  모든 데이터 타입으로 접근 가능한 key-value 자료구조(HashMap, TreeMap)

* 함수

  get(), put(), getOrDefault()

* 사용하는 경우

  String 기반으로 기록하고 관리할 때

* key 정렬하고 싶으면 TreeMap 사용



## Set

중복 ㄴ

key 정렬 : TreeSet



# BFS / DFS

그래프 탐색 알고리즘

* 개념
  * bfs : 여러 드라마 하나씩 보기 
  * dfs : 한 드라마 끝까지 다보기

* 대표 유형
  * 경로 탐색(최단거리, 시간)
  * 네트워크 유형(연결)
  * 조합 만들기

* 구현 방법
  * dfs:  재귀
  * bfs: Queue, LinkedList(순서보장)

* 사용하는 경우
  * dfs : 시간 복잡도가 높음, 디버깅이 쉬움 -> 난이도가 낮은 경우 dfs
  * bfs : 시간 복잡도가 낮음(O(V+E)) -> 난이도가 높거나, dfs 너무 오래걸리는 경우 사용



```java
Queue<int[]> q = new LinkedList<>();
boolean[][] visited = new boolean[n][m];
int ans = 0;

q.add(new int[] {x,y});
visited[x][y] = true;

while(!q.isEmpty()) {
	int len = q.size();
	
	for(int t=0;t<len;t++) {
		int[] now = q.poll();
	
        for(int i=0;i<4;i++) {
            int nx = now[0] + dx[i];
            int ny = now[1] + dy[i];

            if(nx < 0 || nx >= n || ny < 0 || ny >= m) continue;	// 범위
            if(visited[nx][ny]) continue;	// 중복
            if()							// 조건

            q.add(new int[] {nx,ny});
            visited[nx][ny] = true;
		}
	}
	ans++;
}
```



# 재귀

## 메모라이제이션

피보나치

## 분할정복



## 백트래킹(순열, 조합)

1. 순열

   ```java
   dfs(int depth, boolean[] visited);
   ```

2. 조합

   ```java
   dfs(int depth, int idx);
   ```



# 그리디

## 정렬

* 조건
  1. 현재 최적화가 다음 최적화 영향 안줌
  2. 현재 최적화가 모여서 전체 최적화가 됨


* 예시

  최솟값, 최댓값, n번째 수, 중앙값, 강의실 배정



## 위상정렬

단방향 트리 + 추적

* indegree[자식]++
* indegree[idx] == 0 이면 q에 넣기
* indegree[자식]--;  indegree[자식] == 0 이면 q에 넣기  





# union -find 

사이클 확인, 사이클 갯수

int[] parent, union, find



# 이분 탐색

```
// 초기값 주의
int s = x;
int e = y;

while(s <= e) {
	int m = (s+e) / 2;
	// 연산	
	...
	// 조건
	if() s = m + 1;
	else e = m - 1;
}

// return 값 주의(ans,s,e)
```





# 투포인터

연속 합, 연속 짝수, 대칭 확인, 두 수 합





# DP

1. 최댓값, 최솟값

2. 냅색

   비용 b이하 + 가치 최대

   ```java
   for(int i=1;i<=n;i++) {
   	for(int j=0;j<=n;j++) {
   		if(j-cost[i] < 0) continue;
   		dp[i][j] = Math.max(dp[i-1][j],dp[i-1][j-cost[i]]+value[i]);
   	}
   }
   ```

3. LIS

   ```java
   for(int i=1;i<n;i++) {
   	int min = 0;
   	for(int j=0;j<i;j++) {
           if(nums[j] >= nums[i]) continue;
   		max = Math.max(dp[j],max);
   	}
   	dp[i] = dp[j] + 1;
   }
   ```

4. LCS

   1. 최장 부분수열

      ```java
      for(int i=0;i<n;i++) {
      	for(int j=0;j<m;j++) {
      		if(str1.charAt(i) == str2.charAt(j)) dp[i-1][j-1] + 1;
      		else dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1]);
      	}
      }
      ```

   2. 최장 연속 부분수열

      ```java
      for(int i=0;i<n;i++) {
      	for(int j=0;j<m;j++) {
      		if(str1.charAt(i) == str2.charAt(j)) dp[i-1][j-1] + 1;	
      	}
      }
      ```

      



# 트리 최단 거리

1. 다익스트라

   s(고정)-> e(여러개) 최단거리

   pq, dist[] = INF

   O(ElogE)

   ```java
   PriorityQueue<Edge> pq = new PriorityQueue<>();
   Arrays.fill(dist,INF);
   
   pq.add(new Edge{start,0});
   visited[start] = true;
   
   while(!q.isEmpty()) {
       Edge now = pq.poll();
       if(dist[now.idx] < now.dist) continue;
       
       for(Edge next : edges.get(now.idx)) {
           if(visited[next.idx]) continue;
           if(dist[next.idx] > now.dist + next.dist) {
               dist[next.idx] = now.dist + next.dist;
               
               pq.add(new Edge(next,idx,dist[next.idx]));
               visited[next.idx] = true;
           }
       }
   }
   ```
   
   
   
2. 플로이드 워셜

   s(여러개) -> e(여러개)

   * O(V^3) 

   ```java
   for(int i=1;i<=n;i++) {
       for(int j=1;j<=n;j++) {
           for(int k=1;k<=n;k++) {
               dp[j][k] = Math.min(dp[j][k],dp[j][i]+dp[i][k]);
           }
       }
   }
   ```

   

3. 최장신장트리

   순환 ㄴ +  다 연결하기 + 최소

   pq + union-find

   O(ElogE)
   
   ```java
   PriorityQueue<Edge> pq = new PriorityQueue<>();	// cost 오름차순
   StringTokenizer st = new StringTokenizer(br.readLine());
   
   for(int i=0;i<m;i++) {
       int a = Integer.parseInt(st.nextToken());
       int b = Integer.parseInt(st.nextToken());
       int c = Integer.parseInt(st.nextToken());
       pq.add(new Edge(a,b,c));
   }
   
   while(!pq.isEmpty()) {
    	Edge now = pq.poll();
       if(find(now.s) == find(now.e)) continue;
       union(now.s,now.e);
       ans += now.c;
   }
   ```
   
   

# 수학

## 최소공배수, 최대 공약수

```
public int euclid(int a, int b) {
	while(b != 0) {
		int r = a % b;
		a = b;
		b = r;
	}
	return a;
}

// 최소 공배수
int num = a * b / euclid(a,b);

// 최대 공약수
int num = euclid(a,b);
```

## 소수

1. 단일 소수 판별

   ```java
   public boolean checkPrime(int x) {
       for(int i=2;i<=(int)Math.sqrt(x);i++) {
       	if(x % i == 0) return false;
   	}
   
   	return true;
   }
   ```

2. 복수 소수 찾기

   ```java
   boolean[] notPrime = new boolean[x+1];
   for(int i=2;i<=(int)Math.sqrt(x);i++) {
       for(int j=2;j<=x/i;j++) {
           notPrime[i*j] = true;
       }
   }
   ```


## 반올림

```java
String.format(".2f",ans); // 2자리까지 반올림
double test = Math.round(ans*100)/100 // 2째 자리까지 반올림
double test = Math.ceil(ans*100)/100 // 2째 자리까지 올림
double test = Math.floor(ans*100)/100 // 2째 자리까지 내림
```



## 진수

```java
String binaryNum = Integer.toBinaryString(num);
int num = Integer.toparseInt(binaryNum,2);
```



