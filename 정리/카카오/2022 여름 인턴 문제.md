# 1. dkd

###### 문제 설명

나만의 카카오 성격 유형 검사지를 만들려고 합니다.
성격 유형 검사는 다음과 같은 4개 지표로 성격 유형을 구분합니다. 성격은 각 지표에서 두 유형 중 하나로 결정됩니다.

| 지표 번호 | 성격 유형              |
| --------- | ---------------------- |
| 1번 지표  | 라이언형(R), 튜브형(T) |
| 2번 지표  | 콘형(C), 프로도형(F)   |
| 3번 지표  | 제이지형(J), 무지형(M) |
| 4번 지표  | 어피치형(A), 네오형(N) |

4개의 지표가 있으므로 성격 유형은 총 16(=2 x 2 x 2 x 2)가지가 나올 수 있습니다. 예를 들어, "RFMN"이나 "TCMA"와 같은 성격 유형이 있습니다.

검사지에는 총 `n`개의 질문이 있고, 각 질문에는 아래와 같은 7개의 선택지가 있습니다.

- `매우 비동의`
- `비동의`
- `약간 비동의`
- `모르겠음`
- `약간 동의`
- `동의`
- `매우 동의`

각 질문은 1가지 지표로 성격 유형 점수를 판단합니다.

예를 들어, 어떤 한 질문에서 4번 지표로 아래 표처럼 점수를 매길 수 있습니다.

| 선택지        | 성격 유형 점수                        |
| ------------- | ------------------------------------- |
| `매우 비동의` | 네오형 3점                            |
| `비동의`      | 네오형 2점                            |
| `약간 비동의` | 네오형 1점                            |
| `모르겠음`    | 어떤 성격 유형도 점수를 얻지 않습니다 |
| `약간 동의`   | 어피치형 1점                          |
| `동의`        | 어피치형 2점                          |
| `매우 동의`   | 어피치형 3점                          |

이때 검사자가 질문에서 `약간 동의` 선택지를 선택할 경우 어피치형(A) 성격 유형 1점을 받게 됩니다. 만약 검사자가 `매우 비동의` 선택지를 선택할 경우 네오형(N) 성격 유형 3점을 받게 됩니다.

**위 예시처럼 네오형이 비동의, 어피치형이 동의인 경우만 주어지지 않고, 질문에 따라 네오형이 동의, 어피치형이 비동의인 경우도 주어질 수 있습니다.**
하지만 각 선택지는 고정적인 크기의 점수를 가지고 있습니다.

- `매우 동의`나 `매우 비동의` 선택지를 선택하면 3점을 얻습니다.
- `동의`나 `비동의` 선택지를 선택하면 2점을 얻습니다.
- `약간 동의`나 `약간 비동의` 선택지를 선택하면 1점을 얻습니다.
- `모르겠음` 선택지를 선택하면 점수를 얻지 않습니다.

검사 결과는 모든 질문의 성격 유형 점수를 더하여 각 지표에서 더 높은 점수를 받은 성격 유형이 검사자의 성격 유형이라고 판단합니다. 단, 하나의 지표에서 각 성격 유형 점수가 같으면, 두 성격 유형 중 사전 순으로 빠른 성격 유형을 검사자의 성격 유형이라고 판단합니다.

질문마다 판단하는 지표를 담은 1차원 문자열 배열 `survey`와 검사자가 각 질문마다 선택한 선택지를 담은 1차원 정수 배열 `choices`가 매개변수로 주어집니다. 이때, 검사자의 성격 유형 검사 결과를 지표 번호 순서대로 return 하도록 solution 함수를 완성해주세요.

------

##### 제한사항

- 1 ≤

   

  ```
  survey
  ```

  의 길이 ( =

   

  ```
  n
  ```

  ) ≤ 1,000

  - `survey`의 원소는 `"RT", "TR", "FC", "CF", "MJ", "JM", "AN", "NA"` 중 하나입니다.
  - `survey[i]`의 첫 번째 캐릭터는 i+1번 질문의 비동의 관련 선택지를 선택하면 받는 성격 유형을 의미합니다.
  - `survey[i]`의 두 번째 캐릭터는 i+1번 질문의 동의 관련 선택지를 선택하면 받는 성격 유형을 의미합니다.

- `choices`의 길이 = `survey`의 길이

  - `choices[i]`는 검사자가 선택한 i+1번째 질문의 선택지를 의미합니다.
  - 1 ≤ `choices`의 원소 ≤ 7

  | `choices` | 뜻          |
  | --------- | ----------- |
  | 1         | 매우 비동의 |
  | 2         | 비동의      |
  | 3         | 약간 비동의 |
  | 4         | 모르겠음    |
  | 5         | 약간 동의   |
  | 6         | 동의        |
  | 7         | 매우 동의   |

------

##### 입출력 예

| survey                           | choices         | result   |
| -------------------------------- | --------------- | -------- |
| `["AN", "CF", "MJ", "RT", "NA"]` | [5, 3, 2, 7, 5] | `"TCMA"` |
| `["TR", "RT", "TR"]`             | [7, 1, 3]       | `"RCJA"` |

------

##### 입출력 예 설명

**입출력 예 #1**

1번 질문의 점수 배치는 아래 표와 같습니다.

| 선택지        | 성격 유형 점수                        |
| ------------- | ------------------------------------- |
| 매우 비동의   | 어피치형 3점                          |
| 비동의        | 어피치형 2점                          |
| 약간 비동의   | 어피치형 1점                          |
| 모르겠음      | 어떤 성격 유형도 점수를 얻지 않습니다 |
| **약간 동의** | **네오형 1점**                        |
| 동의          | 네오형 2점                            |
| 매우 동의     | 네오형 3점                            |

1번 질문에서는 지문의 예시와 다르게 비동의 관련 선택지를 선택하면 어피치형(A) 성격 유형의 점수를 얻고, 동의 관련 선택지를 선택하면 네오형(N) 성격 유형의 점수를 얻습니다.
1번 질문에서 검사자는 `약간 동의` 선택지를 선택했으므로 네오형(N) 성격 유형 점수 1점을 얻게 됩니다.

2번 질문의 점수 배치는 아래 표와 같습니다.

| 선택지          | 성격 유형 점수                        |
| --------------- | ------------------------------------- |
| 매우 비동의     | 콘형 3점                              |
| 비동의          | 콘형 2점                              |
| **약간 비동의** | **콘형 1점**                          |
| 모르겠음        | 어떤 성격 유형도 점수를 얻지 않습니다 |
| 약간 동의       | 프로도형 1점                          |
| 동의            | 프로도형 2점                          |
| 매우 동의       | 프로도형 3점                          |

2번 질문에서 검사자는 `약간 비동의` 선택지를 선택했으므로 콘형(C) 성격 유형 점수 1점을 얻게 됩니다.

3번 질문의 점수 배치는 아래 표와 같습니다.

| 선택지      | 성격 유형 점수                        |
| ----------- | ------------------------------------- |
| 매우 비동의 | 무지형 3점                            |
| **비동의**  | **무지형 2점**                        |
| 약간 비동의 | 무지형 1점                            |
| 모르겠음    | 어떤 성격 유형도 점수를 얻지 않습니다 |
| 약간 동의   | 제이지형 1점                          |
| 동의        | 제이지형 2점                          |
| 매우 동의   | 제이지형 3점                          |

3번 질문에서 검사자는 `비동의` 선택지를 선택했으므로 무지형(M) 성격 유형 점수 2점을 얻게 됩니다.

4번 질문의 점수 배치는 아래 표와 같습니다.

| 선택지        | 성격 유형 점수                        |
| ------------- | ------------------------------------- |
| 매우 비동의   | 라이언형 3점                          |
| 비동의        | 라이언형 2점                          |
| 약간 비동의   | 라이언형 1점                          |
| 모르겠음      | 어떤 성격 유형도 점수를 얻지 않습니다 |
| 약간 동의     | 튜브형 1점                            |
| 동의          | 튜브형 2점                            |
| **매우 동의** | **튜브형 3점**                        |

4번 질문에서 검사자는 `매우 동의` 선택지를 선택했으므로 튜브형(T) 성격 유형 점수 3점을 얻게 됩니다.

5번 질문의 점수 배치는 아래 표와 같습니다.

| 선택지        | 성격 유형 점수                        |
| ------------- | ------------------------------------- |
| 매우 비동의   | 네오형 3점                            |
| 비동의        | 네오형 2점                            |
| 약간 비동의   | 네오형 1점                            |
| 모르겠음      | 어떤 성격 유형도 점수를 얻지 않습니다 |
| **약간 동의** | **어피치형 1점**                      |
| 동의          | 어피치형 2점                          |
| 매우 동의     | 어피치형 3점                          |

5번 질문에서 검사자는 `약간 동의` 선택지를 선택했으므로 어피치형(A) 성격 유형 점수 1점을 얻게 됩니다.

1번부터 5번까지 질문의 성격 유형 점수를 합치면 아래 표와 같습니다.

| 지표 번호 | 성격 유형   | 점수 | 성격 유형   | 점수 |
| --------- | ----------- | ---- | ----------- | ---- |
| 1번 지표  | 라이언형(R) | 0    | 튜브형(T)   | 3    |
| 2번 지표  | 콘형(C)     | 1    | 프로도형(F) | 0    |
| 3번 지표  | 제이지형(J) | 0    | 무지형(M)   | 2    |
| 4번 지표  | 어피치형(A) | 1    | 네오형(N)   | 1    |

각 지표에서 더 점수가 높은 `T`,`C`,`M`이 성격 유형입니다.
하지만, 4번 지표는 1점으로 동일한 점수입니다. 따라서, 4번 지표의 성격 유형은 사전순으로 빠른 `A`입니다.

따라서 `"TCMA"`를 return 해야 합니다.

**입출력 예 #2**

1번부터 3번까지 질문의 성격 유형 점수를 합치면 아래 표와 같습니다.

| 지표 번호 | 성격 유형   | 점수 | 성격 유형   | 점수 |
| --------- | ----------- | ---- | ----------- | ---- |
| 1번 지표  | 라이언형(R) | 6    | 튜브형(T)   | 1    |
| 2번 지표  | 콘형(C)     | 0    | 프로도형(F) | 0    |
| 3번 지표  | 제이지형(J) | 0    | 무지형(M)   | 0    |
| 4번 지표  | 어피치형(A) | 0    | 네오형(N)   | 0    |

1번 지표는 튜브형(T)보다 라이언형(R)의 점수가 더 높습니다. 따라서 첫 번째 지표의 성격 유형은 `R`입니다.
하지만, 2, 3, 4번 지표는 모두 0점으로 동일한 점수입니다. 따라서 2, 3, 4번 지표의 성격 유형은 사전순으로 빠른 `C`, `J`, `A`입니다.

따라서 `"RCJA"`를 return 해야 합니다.



# 2. d

###### 문제 설명

길이가 같은 두 개의 큐가 주어집니다. 하나의 큐를 골라 원소를 추출(pop)하고, 추출된 원소를 **다른 큐**에 집어넣는(insert) 작업을 통해 각 큐의 원소 합이 같도록 만들려고 합니다. 이때 필요한 작업의 최소 횟수를 구하고자 합니다. 한 번의 pop과 한 번의 insert를 합쳐서 작업을 1회 수행한 것으로 간주합니다.

큐는 먼저 집어넣은 원소가 먼저 나오는 구조입니다. 이 문제에서는 큐를 배열로 표현하며, 원소가 배열 앞쪽에 있을수록 먼저 집어넣은 원소임을 의미합니다. 즉, pop을 하면 배열의 첫 번째 원소가 추출되며, insert를 하면 배열의 끝에 원소가 추가됩니다. 예를 들어 큐 `[1, 2, 3, 4]`가 주어졌을 때, pop을 하면 맨 앞에 있는 원소 1이 추출되어 `[2, 3, 4]`가 되며, 이어서 5를 insert하면 `[2, 3, 4, 5]`가 됩니다.

다음은 두 큐를 나타내는 예시입니다.

```
queue1 = [3, 2, 7, 2]
queue2 = [4, 6, 5, 1]
```

두 큐에 담긴 모든 원소의 합은 30입니다. 따라서, 각 큐의 합을 15로 만들어야 합니다. 예를 들어, 다음과 같이 2가지 방법이 있습니다.

1. queue2의 4, 6, 5를 순서대로 추출하여 queue1에 추가한 뒤, queue1의 3, 2, 7, 2를 순서대로 추출하여 queue2에 추가합니다. 그 결과 queue1은 [4, 6, 5], queue2는 [1, 3, 2, 7, 2]가 되며, 각 큐의 원소 합은 15로 같습니다. 이 방법은 작업을 7번 수행합니다.
2. queue1에서 3을 추출하여 queue2에 추가합니다. 그리고 queue2에서 4를 추출하여 queue1에 추가합니다. 그 결과 queue1은 [2, 7, 2, 4], queue2는 [6, 5, 1, 3]가 되며, 각 큐의 원소 합은 15로 같습니다. 이 방법은 작업을 2번만 수행하며, 이보다 적은 횟수로 목표를 달성할 수 없습니다.

따라서 각 큐의 원소 합을 같게 만들기 위해 필요한 작업의 최소 횟수는 2입니다.

길이가 같은 두 개의 큐를 나타내는 정수 배열 `queue1`, `queue2`가 매개변수로 주어집니다. 각 큐의 원소 합을 같게 만들기 위해 필요한 작업의 최소 횟수를 return 하도록 solution 함수를 완성해주세요. 단, 어떤 방법으로도 각 큐의 원소 합을 같게 만들 수 없는 경우, -1을 return 해주세요.

------

##### 제한사항

- 1 ≤ `queue1`의 길이 = `queue2`의 길이 ≤ 300,000
- 1 ≤ `queue1`의 원소, `queue2`의 원소 ≤ 109
- 주의: 언어에 따라 합 계산 과정 중 산술 오버플로우 발생 가능성이 있으므로 long type 고려가 필요합니다.

------

##### 입출력 예

| queue1       | queue2        | result |
| ------------ | ------------- | ------ |
| [3, 2, 7, 2] | [4, 6, 5, 1]  | 2      |
| [1, 2, 1, 2] | [1, 10, 1, 2] | 7      |
| [1, 1]       | [1, 5]        | -1     |

------

##### 입출력 예 설명

**입출력 예 #1**

문제 예시와 같습니다.

**입출력 예 #2**

두 큐에 담긴 모든 원소의 합은 20입니다. 따라서, 각 큐의 합을 10으로 만들어야 합니다. queue2에서 1, 10을 순서대로 추출하여 queue1에 추가하고, queue1에서 1, 2, 1, 2와 1(queue2으로부터 받은 원소)을 순서대로 추출하여 queue2에 추가합니다. 그 결과 queue1은 [10], queue2는 [1, 2, 1, 2, 1, 2, 1]가 되며, 각 큐의 원소 합은 10으로 같습니다. 이때 작업 횟수는 7회이며, 이보다 적은 횟수로 목표를 달성하는 방법은 없습니다. 따라서 7를 return 합니다.

**입출력 예 #3**

어떤 방법을 쓰더라도 각 큐의 원소 합을 같게 만들 수 없습니다. 따라서 -1을 return 합니다.



# 3. fads

###### 문제 설명

**[본 문제는 정확성과 효율성 테스트 각각 점수가 있는 문제입니다.]**

당신은 코딩 테스트를 준비하기 위해 공부하려고 합니다. 코딩 테스트 문제를 풀기 위해서는 알고리즘에 대한 지식과 코드를 구현하는 능력이 필요합니다.

알고리즘에 대한 지식은 `알고력`, 코드를 구현하는 능력은 `코딩력`이라고 표현합니다. `알고력`과 `코딩력`은 0 이상의 정수로 표현됩니다.

문제를 풀기 위해서는 문제가 요구하는 일정 이상의 `알고력`과 `코딩력`이 필요합니다.

예를 들어, 당신의 현재 `알고력`이 15, `코딩력`이 10이라고 가정해보겠습니다.

- A라는 문제가 `알고력` 10, `코딩력` 10을 요구한다면 A 문제를 풀 수 있습니다.
- B라는 문제가 `알고력` 10, `코딩력` 20을 요구한다면 `코딩력`이 부족하기 때문에 B 문제를 풀 수 없습니다.

풀 수 없는 문제를 해결하기 위해서는 `알고력`과 `코딩력`을 높여야 합니다. `알고력`과 `코딩력`을 높이기 위한 다음과 같은 방법들이 있습니다.

- `알고력`을 높이기 위해 알고리즘 공부를 합니다. `알고력` 1을 높이기 위해서 1의 시간이 필요합니다.
- `코딩력`을 높이기 위해 코딩 공부를 합니다. `코딩력` 1을 높이기 위해서 1의 시간이 필요합니다.
- 현재 풀 수 있는 문제 중 하나를 풀어 `알고력`과 `코딩력`을 높입니다. 각 문제마다 문제를 풀면 올라가는 알고력과 코딩력이 정해져 있습니다.
- 문제를 하나 푸는 데는 문제가 요구하는 시간이 필요하며 같은 문제를 여러 번 푸는 것이 가능합니다.

당신은 주어진 모든 문제들을 풀 수 있는 `알고력`과 `코딩력`을 얻는 최단시간을 구하려 합니다.

초기의 `알고력`과 `코딩력`을 담은 정수 `alp`와 `cop`, 문제의 정보를 담은 2차원 정수 배열 `problems`가 매개변수로 주어졌을 때, 모든 문제들을 풀 수 있는 `알고력`과 `코딩력`을 얻는 최단시간을 return 하도록 solution 함수를 작성해주세요.

**모든 문제들을 1번 이상씩 풀 필요는 없습니다.**

------

##### 제한사항

- 초기의

   

  ```
  알고력
  ```

  을 나타내는

   

  ```
  alp
  ```

  와 초기의

   

  ```
  코딩력
  ```

  을 나타내는

   

  ```
  cop
  ```

  가 입력으로 주어집니다.

  - 0 ≤ `alp`,`cop` ≤ 150

- 1 ≤ `problems`의 길이 ≤ 100

- `problems`의 원소는 [`alp_req`, `cop_req`, `alp_rwd`, `cop_rwd`, `cost`]의 형태로 이루어져 있습니다.

- ```
  alp_req
  ```

  는 문제를 푸는데 필요한

   

  ```
  알고력
  ```

  입니다.

  - 0 ≤ `alp_req` ≤ 150

- ```
  cop_req
  ```

  는 문제를 푸는데 필요한

   

  ```
  코딩력
  ```

  입니다.

  - 0 ≤ `cop_req` ≤ 150

- ```
  alp_rwd
  ```

  는 문제를 풀었을 때 증가하는

   

  ```
  알고력
  ```

  입니다.

  - 0 ≤ `alp_rwd` ≤ 30

- ```
  cop_rwd
  ```

  는 문제를 풀었을 때 증가하는

   

  ```
  코딩력
  ```

  입니다.

  - 0 ≤ `cop_rwd` ≤ 30

- ```
  cost
  ```

  는 문제를 푸는데 드는 시간입니다.

  - 1 ≤ `cost` ≤ 100

------

##### 입출력 예

| alp  | cop  | problems                                            | result |
| ---- | ---- | --------------------------------------------------- | ------ |
| 10   | 10   | [[10,15,2,1,2],[20,20,3,3,4]]                       | 15     |
| 0    | 0    | [[0,0,2,1,2],[4,5,3,1,2],[4,11,4,0,2],[10,4,0,4,2]] | 13     |

------

##### 입출력 예 설명

**입출력 예 #1**

1. `코딩력` 5를 늘립니다. `알고력` 10, `코딩력` 15가 되며 시간이 5만큼 소요됩니다.
2. 1번 문제를 5번 풉니다. `알고력` 20, `코딩력` 20이 되며 시간이 10만큼 소요됩니다. 15의 시간을 소요하여 모든 문제를 풀 수 있는 `알고력`과 `코딩력`을 가질 수 있습니다.

**입출력 예 #2**

1. 1번 문제를 2번 풉니다. `알고력` 4, `코딩력` 2가 되며 시간이 4만큼 소요됩니다.
2. `코딩력` 3을 늘립니다. `알고력` 4, `코딩력` 5가 되며 시간이 3만큼 소요됩니다.
3. 2번 문제를 2번 풉니다. `알고력` 10, `코딩력` 7이 되며 시간이 4만큼 소요됩니다.
4. 4번 문제를 1번 풉니다. `알고력` 10, `코딩력` 11이 되며 시간이 2만큼 소요됩니다. 13의 시간을 소요하여 모든 문제를 풀 수 있는 `알고력`과 `코딩력`을 가질 수 있습니다.

------

**제한시간 안내**

- 정확성 테스트 : 10초
- 효율성 테스트 : 언어별로 작성된 정답 코드의 실행 시간의 적정 배수



# 4. 

###### 문제 설명

XX산은 `n`개의 지점으로 이루어져 있습니다. 각 지점은 1부터 `n`까지 번호가 붙어있으며, 출입구, 쉼터, 혹은 산봉우리입니다. 각 지점은 양방향 통행이 가능한 등산로로 연결되어 있으며, 서로 다른 지점을 이동할 때 이 등산로를 이용해야 합니다. 이때, 등산로별로 이동하는데 일정 시간이 소요됩니다.

등산코스는 방문할 지점 번호들을 순서대로 나열하여 표현할 수 있습니다.
예를 들어 `1-2-3-2-1` 으로 표현하는 등산코스는 1번지점에서 출발하여 2번, 3번, 2번, 1번 지점을 순서대로 방문한다는 뜻입니다.
등산코스를 따라 이동하는 중 쉼터 혹은 산봉우리를 방문할 때마다 휴식을 취할 수 있으며, 휴식 없이 이동해야 하는 시간 중 가장 긴 시간을 해당 등산코스의 `intensity`라고 부르기로 합니다.

당신은 XX산의 출입구 중 한 곳에서 출발하여 산봉우리 중 한 곳만 방문한 뒤 다시 **원래의** 출입구로 돌아오는 등산코스를 정하려고 합니다. 다시 말해, 등산코스에서 출입구는 **처음과 끝에 한 번씩**, 산봉우리는 **한 번만** 포함되어야 합니다.
당신은 이러한 규칙을 지키면서 `intensity`가 최소가 되도록 등산코스를 정하려고 합니다.

다음은 XX산의 지점과 등산로를 그림으로 표현한 예시입니다.
![desc1-1.PNG](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/d1764091-629a-414b-9f77-e2ff1b38c6e0/desc1-1.PNG)

- 위 그림에서 원에 적힌 숫자는 지점의 번호를 나타내며, 1, 3번 지점에 출입구, 5번 지점에 산봉우리가 있습니다. 각 선분은 등산로를 나타내며, 각 선분에 적힌 수는 이동 시간을 나타냅니다. 예를 들어 1번 지점에서 2번 지점으로 이동할 때는 3시간이 소요됩니다.

위의 예시에서 `1-2-5-4-3` 과 같은 등산코스는 처음 출발한 원래의 출입구로 돌아오지 않기 때문에 잘못된 등산코스입니다. 또한 `1-2-5-6-4-3-2-1` 과 같은 등산코스는 코스의 처음과 끝 외에 3번 출입구를 방문하기 때문에 잘못된 등산코스입니다.

등산코스를 `3-2-5-4-3` 과 같이 정했을 때의 이동경로를 그림으로 나타내면 아래와 같습니다.
![desc1-2.PNG](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/ae2b6ccd-290b-4074-aebe-028c13dc4cbe/desc1-2.PNG)
이때, 휴식 없이 이동해야 하는 시간 중 가장 긴 시간은 5시간입니다. 따라서 이 등산코스의 `intensity`는 5입니다.

등산코스를 `1-2-4-5-6-4-2-1` 과 같이 정했을 때의 이동경로를 그림으로 나타내면 아래와 같습니다.
![desc1-3.PNG](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/165bcca3-ee06-46b4-95f8-7c3cedd2cb42/desc1-3.PNG)
이때, 휴식 없이 이동해야 하는 시간 중 가장 긴 시간은 3시간입니다. 따라서 이 등산코스의 `intensity`는 3이며, 이 보다 `intensity`가 낮은 등산코스는 없습니다.

XX산의 지점 수 `n`, 각 등산로의 정보를 담은 2차원 정수 배열 `paths`, 출입구들의 번호가 담긴 정수 배열 `gates`, 산봉우리들의 번호가 담긴 정수 배열 `summits`가 매개변수로 주어집니다. 이때, `intensity`가 최소가 되는 등산코스에 포함된 산봉우리 번호와 `intensity`의 최솟값을 차례대로 정수 배열에 담아 return 하도록 solution 함수를 완성해주세요. `intensity`가 최소가 되는 등산코스가 여러 개라면 그중 산봉우리의 번호가 가장 낮은 등산코스를 선택합니다.

------

##### 제한사항

- 2 ≤ `n` ≤ 50,000

- `n` - 1 ≤ `paths`의 길이 ≤ 200,000

- ```
  paths
  ```

  의 원소는

   

  ```
  [i, j, w]
  ```

   

  형태입니다.

  - `i`번 지점과 `j`번 지점을 연결하는 등산로가 있다는 뜻입니다.
  - `w`는 두 지점 사이를 이동하는 데 걸리는 시간입니다.
  - 1 ≤ `i` < `j` ≤ `n`
  - 1 ≤ `w` ≤ 10,000,000
  - 서로 다른 두 지점을 직접 연결하는 등산로는 최대 1개입니다.

- 1 ≤

   

  ```
  gates
  ```

  의 길이 ≤

   

  ```
  n
  ```

  - 1 ≤ `gates`의 원소 ≤ `n`
  - `gates`의 원소는 해당 지점이 출입구임을 나타냅니다.

- 1 ≤

   

  ```
  summits
  ```

  의 길이 ≤

   

  ```
  n
  ```

  - 1 ≤ `summits`의 원소 ≤ `n`
  - `summits`의 원소는 해당 지점이 산봉우리임을 나타냅니다.

- 출입구이면서 동시에 산봉우리인 지점은 없습니다.

- `gates`와 `summits`에 등장하지 않은 지점은 모두 쉼터입니다.

- 임의의 두 지점 사이에 이동 가능한 경로가 항상 존재합니다.

- return 하는 배열은 `[산봉우리의 번호, intensity의 최솟값]` 순서여야 합니다.

------

##### 입출력 예

| n    | paths                                                        | gates  | summits   | result |
| ---- | ------------------------------------------------------------ | ------ | --------- | ------ |
| 6    | [[1, 2, 3], [2, 3, 5], [2, 4, 2], [2, 5, 4], [3, 4, 4], [4, 5, 3], [4, 6, 1], [5, 6, 1]] | [1, 3] | [5]       | [5, 3] |
| 7    | [[1, 4, 4], [1, 6, 1], [1, 7, 3], [2, 5, 2], [3, 7, 4], [5, 6, 6]] | [1]    | [2, 3, 4] | [3, 4] |
| 7    | [[1, 2, 5], [1, 4, 1], [2, 3, 1], [2, 6, 7], [4, 5, 1], [5, 6, 1], [6, 7, 1]] | [3, 7] | [1, 5]    | [5, 1] |
| 5    | [[1, 3, 10], [1, 4, 20], [2, 3, 4], [2, 4, 6], [3, 5, 20], [4, 5, 6]] | [1, 2] | [5]       | [5, 6] |

------

##### 입출력 예 설명

**입출력 예 #1**

문제 예시와 같습니다. 등산코스의 `intensity`가 최소가 되는 산봉우리 번호는 5, `intensity`의 최솟값은 3이므로 `[5, 3]`을 return 해야 합니다.

**입출력 예 #2**

XX산의 지점과 등산로를 그림으로 표현하면 아래와 같습니다.

![ex2.PNG](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/b978b0f5-7e8b-4dbe-aeb0-a6c21a3431e4/ex2.PNG)

가능한 `intensity`의 최솟값은 4이며, `intensity`가 4가 되는 등산코스는 `1-4-1` 과 `1-7-3-7-1` 이 있습니다. `intensity`가 최소가 되는 등산코스가 여러 개이므로 둘 중 산봉우리의 번호가 낮은 `1-7-3-7-1` 을 선택합니다. 따라서 `[3, 4]`를 return 해야 합니다.

**입출력 예 #3**

XX산의 지점과 등산로를 그림으로 표현하면 아래와 같습니다.

![ex3.PNG](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/53399b93-368c-42bd-ad68-1230f59479c8/ex3.PNG)

가능한 `intensity`의 최솟값은 1이며, 그때의 등산코스는 `7-6-5-6-7` 입니다. 따라서 `[5, 1]`를 return 해야 합니다.

- `7-6-5-4-1-4-5-6-7` 과 같은 등산코스는 산봉우리를 여러 번 방문하기 때문에 잘못된 등산코스입니다.

**입출력 예 #4**

XX산의 지점과 등산로를 그림으로 표현하면 아래와 같습니다.

![ex4.PNG](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/0abfa9ed-7b1a-4619-a23d-1becf94d1bc3/ex4.PNG)

가능한 `intensity`의 최솟값은 6, 그때의 등산코스는 `2-4-5-4-2` 입니다. 따라서 `[5, 6]`을 return 해야 합니다.



# 5. 

###### 문제 설명

**[본 문제는 정확성과 효율성 테스트 각각 점수가 있는 문제입니다.]**

당신은 행렬에 적용할 수 있는 두 가지 연산을 만들었습니다.

- ShiftRow

  - 모든 행이 아래쪽으로 한 칸씩 밀려납니다. 즉, 모든 행에 대해서 `i`번째 행은 `i+1`번째 행이 됩니다. (마지막 행은 1번째 행이 됩니다.)

  - ShiftRow의 예

     

    

    - 왼쪽 행렬이 초기 상태이고 오른쪽 행렬이 ShiftRow를 한 번 시행한 뒤의 행렬입니다.
    - 1번째 행에 있던 [1,2,3]이 2번째 행으로, 2번째 행에 있던 [4,5,6]이 3번째 행으로, 3번째 행에 있던 [7,8,9]가 1번째 행이 된 것을 확인할 수 있습니다.

- Rotate

  - 행렬의 바깥쪽에 있는 원소들을 시계 방향으로 한 칸 회전시킵니다.

  - 행렬의 바깥쪽에 있는 원소들은 첫 행, 첫 열, 끝 행, 끝 열에 포함되는 원소들입니다.

  - 한 칸 회전시킨다는 것은 이 원소들이 시계 방향으로 한 칸씩 밀려난다는 것을 의미합니다. 즉, 다음 4개의 연산이 동시에 시행됩니다.

    - 첫 행에서 끝 열에 있는 원소를 제외한 첫 행의 모든 원소는 오른쪽으로 한 칸 이동합니다.
    - 끝 열에서 끝 행에 있는 원소를 제외한 끝 열의 모든 원소는 아래쪽으로 한 칸 이동합니다.
    - 끝 행에서 첫 열에 있는 원소를 제외한 끝 행의 모든 원소는 왼쪽으로 한 칸 이동합니다.
    - 첫 열에서 첫 행에 있는 원소를 제외한 첫 열의 모든 원소는 위쪽으로 한 칸 이동합니다.

  - Rotate의 예

     

    

    - 왼쪽 행렬이 초기 상태이고 오른쪽 행렬이 Rotate를 한 번 시행한 뒤의 행렬입니다.
    - 바깥쪽에 있는 값들이 시계 방향으로 한 칸씩 이동한 것을 확인할 수 있습니다.

당신은 행렬에 연산을 여러 번 시행하려고 합니다.
행렬의 초기 상태를 담고 있는 2차원 정수 배열 `rc`, 시행할 연산을 순서대로 담고 있는 문자열 배열 `operations`가 매개변수로 주어졌을 때, 연산을 차례대로 시행한 후의 행렬 상태를 return 하도록 solution 함수를 완성해주세요.

------

##### 제한사항

- 2 ≤

   

  ```
  rc
  ```

  의 행 길이(=행렬의 가로 길이) ≤ 50,000

  - `rc`의 모든 행의 길이는 동일합니다.

- 2 ≤

   

  ```
  rc
  ```

  의 열 길이(=행렬의 세로 길이) ≤ 50,000

  - `rc`의 모든 열의 길이는 동일합니다.

- 4 ≤ `rc`의 행 길이 x `rc`의 열 길이 ≤ 100,000

- ```
  rc[i][j]
  ```

   

  는

   

  ```
  i+1
  ```

  번째 행

   

  ```
  j+1
  ```

  번째 열에 있는 원소를 나타냅니다.

  - 1 ≤ `rc[i][j]` ≤ 1,000,000

- 1 ≤

   

  ```
  operations
  ```

  의 길이 ≤ 100,000

  - `operations`의 원소는 `"ShiftRow"` 혹은 `"Rotate"`입니다.

**정확성 테스트 케이스 제한 사항**

- 2 ≤

   

  ```
  rc
  ```

  의 행 길이(=행렬의 가로 길이) ≤ 1,000

  - `rc`의 모든 행의 길이는 동일합니다.

- 2 ≤

   

  ```
  rc
  ```

  의 열 길이(=행렬의 세로 길이) ≤ 1,000

  - `rc`의 모든 열의 길이는 동일합니다.

- 4 ≤ `rc`의 행 길이 x `rc`의 열 길이 ≤ 10,000

- 1 ≤ `operations`의 길이 ≤ 100

**효율성 테스트 케이스 제한 사항**

- 주어진 조건 외 추가 제한사항 없습니다.

------

##### 입출력 예

| rc                                            | operations                                     | result                                        |
| --------------------------------------------- | ---------------------------------------------- | --------------------------------------------- |
| [[1, 2, 3], [4, 5, 6], [7, 8, 9]]             | `["Rotate", "ShiftRow"]`                       | [[8, 9, 6], [4, 1, 2], [7, 5, 3]]             |
| [[8, 6, 3], [3, 3, 7], [8, 4, 9]]             | `["Rotate", "ShiftRow", "ShiftRow"]`           | [[8, 3, 3], [4, 9, 7], [3, 8, 6]]             |
| [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]] | `["ShiftRow", "Rotate", "ShiftRow", "Rotate"]` | [[1, 6, 7 ,8], [5, 9, 10, 4], [2, 3, 12, 11]] |

------

##### 입출력 예 설명

**입출력 예#1**

![Untitled Diagram.drawio (50).png](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/e409e001-6e7b-4695-9d8b-4a2abf0e6042/Untitled%20Diagram.drawio%20%2850%29.png)

위 그림은 `”Rotate”`와 `”ShiftRow”`를 차례대로 실행한 결과입니다.

따라서 [[8, 9, 6], [4, 1, 2], [7, 5, 3]]을 return 해야 합니다.

**입출력 예#2**

![Untitled Diagram.drawio (49).png](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/9005dfbe-288c-4dfd-8073-abe2eb594885/Untitled%20Diagram.drawio%20%2849%29.png)

위 그림은 `”Rotate”`, `”ShiftRow”`, `"ShiftRow"`를 차례대로 실행한 결과입니다.

따라서 [[8, 3, 3], [4, 9, 7], [3, 8, 6]]을 return 해야 합니다.

**입출력 예#3**

![Untitled Diagram.drawio (54).png](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/35ca2a90-0c48-4521-bf00-7bc9c4e8a18d/Untitled%20Diagram.drawio%20%2854%29.png)

위 그림은 `”ShiftRow”`, `”Rotate”`, `”ShiftRow”`, `”Rotate”`를 차례대로 실행한 결과입니다.

따라서 [[1, 6, 7 ,8], [5, 9, 10, 4], [2, 3, 12, 11]]을 return 해야 합니다.

------

**제한시간 안내**

- 정확성 테스트 : 10초
- 효율성 테스트 : 언어별로 작성된 정답 코드의 실행 시간의 적정 배수